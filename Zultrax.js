// Generated by CoffeeScript 1.4.0
(function() {
  var Asteroid, BasicFrame, Bullet, CIRCLE, DYNAMIC, Entity, Frame, Game, KEY_DOWN_ARROW, KEY_LEFT_SHIFT, KEY_SPACE, KEY_UP_ARROW, Missile, Mobile, NON_OPERATOR, NON_PHYSICAL, OPERATOR, Player, PlayerAnimation, Portal, RECTANGLE, STATIC, Wall, pointInRect, pointWithin, start, testWall,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  pointWithin = function(x, xa, xb) {
    return x > xa && x < xb;
  };

  pointInRect = function(x1, y1, rectx, recty, halfrectwid, halfrectlen) {
    return (rectx - halfrectwid < x1 && x1 < (rectx + halfrectwid)) && (recty - halfrectlen < y1 && y1 < (recty + halfrectlen));
  };

  KEY_SPACE = 32;

  KEY_UP_ARROW = 38;

  KEY_DOWN_ARROW = 40;

  KEY_LEFT_SHIFT = 16;

  STATIC = 0;

  DYNAMIC = 1;

  NON_PHYSICAL = 0;

  RECTANGLE = 1;

  CIRCLE = 2;

  NON_OPERATOR = 0;

  OPERATOR = 1;

  Game = (function() {

    function Game(canvas) {
      this.canvas = canvas;
      this.context = this.canvas.getContext("2d");
      this.viewFocus = 0;
      this.mousex = 0;
      this.mousey = 0;
      this.events = [];
      this.screenHeight = 1;
      this.screenWidth = 1;
      this.frames = [];
      this.graphics = {};
      this.loadGraphics();
      this.loadIntervalId = null;
      this.loadingComplete = false;
    }

    Game.prototype.init = function() {};

    Game.prototype.run = function() {
      var frame, _i, _len, _ref;
      _ref = this.frames;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        frame = _ref[_i];
        if (frame.active) {
          frame.run(1, this.context, this.events, this.mousex, this.mousey);
        }
      }
      return this.events = [];
    };

    Game.prototype.loadGraphics = function() {
      var i, _i, _results;
      this.graphics['resources/warrior1_0-test-01.png'] = new Image();
      this.graphics['resources/warrior1_0-test-01.png'].src = 'resources/warrior1_0-test-01.png';
      this.graphics['resources/jswars_gfx/asteroid.png'] = new Image();
      this.graphics['resources/jswars_gfx/asteroid.png'].src = 'resources/jswars_gfx/asteroid.png';
      this.graphics['resources/background_1.png'] = new Image();
      this.graphics['resources/background_1.png'].src = 'resources/background_1.png';
      this.graphics['resources/gems2-15.png'] = new Image();
      this.graphics['resources/gems2-15.png'].src = 'resources/gems2-15.png';
      _results = [];
      for (i = _i = 0; _i <= 7; i = ++_i) {
        this.graphics['resources/shieldAnimation/pwr02test2-' + i + '.png'] = new Image();
        _results.push(this.graphics['resources/shieldAnimation/pwr02test2-' + i + '.png'].src = 'resources/shieldAnimation/pwr02test2-' + i + '.png');
      }
      return _results;
    };

    Game.prototype.loadProgress = function() {
      var image, src, _ref, _results;
      this.loadingComplete = true;
      _ref = this.graphics;
      _results = [];
      for (src in _ref) {
        image = _ref[src];
        if (!image.complete) {
          _results.push(this.loadingComplete = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Game;

  })();

  Frame = (function() {

    function Frame(width, height, graphics) {
      this.width = width;
      this.height = height;
      this.graphics = graphics;
      this.player = 0;
      this.map = [];
      this.collisionCellSidelength = 10;
      this.active = false;
      this.collisionMapWidth = Math.floor(this.width / this.collisionCellSidelength);
      this.collisionMapHeight = Math.floor(this.height / this.collisionCellSidelength);
      this.collisionMap = [];
      this.idCount = 0;
      this.background = this.graphics['resources/background_1.png'];
    }

    Frame.prototype.draw = function(context) {
      return context.drawImage(this.background, 0, 0, this.width, this.height);
    };

    Frame.prototype.newId = function() {
      this.idCount++;
      return String(this.idCount);
    };

    Frame.prototype.run = function(elapsedTime, context, events, mousex, mousey) {
      var cell, column, entity, i, partner, splices, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _results;
      this.collisionMap = (function() {
        var _i, _ref, _results;
        _results = [];
        for (column = _i = 0, _ref = this.collisionMapWidth; 0 <= _ref ? _i < _ref : _i > _ref; column = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (cell = _j = 0, _ref1 = this.collisionMapHeight; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; cell = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push([]);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      _ref = this.map;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        entity.updateInput(events, mousex, mousey);
        entity.run(elapsedTime);
        this.writeToCollisionMap(entity);
      }
      _ref1 = this.map;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        entity = _ref1[_j];
        if (entity.collisionType === DYNAMIC && entity.alive) {
          console.log(entity.id + ': velocity+');
          partner = this.doesCollide(entity);
          if (partner !== false) {
            this.collide(entity, partner);
          }
        }
      }
      splices = 0;
      for (i = _k = 0, _ref2 = this.map.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        if (i < this.map.length - splices) {
          if (!this.map[i].alive) {
            this.map.splice(i, 1);
            i -= 1;
            splices++;
          }
        }
      }
      this.draw(context);
      _ref3 = this.map;
      _results = [];
      for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
        entity = _ref3[_l];
        _results.push(entity.draw(context));
      }
      return _results;
    };

    Frame.prototype.writeToCollisionMap = function(entity) {
      var x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _results, _results1;
      if (entity.hitboxType === CIRCLE) {
        _results = [];
        for (x = _i = _ref = Math.floor((entity.x - entity.radius) / this.collisionCellSidelength), _ref1 = Math.floor((entity.x + entity.radius) / this.collisionCellSidelength); _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref2, _ref3, _results1;
            _results1 = [];
            for (y = _j = _ref2 = Math.floor((entity.y - entity.radius) / this.collisionCellSidelength), _ref3 = Math.floor((entity.y + entity.radius) / this.collisionCellSidelength); _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
              if ((0 < x && x < this.collisionMapWidth) && (0 < y && y < this.collisionMapHeight)) {
                _results1.push(this.collisionMap[x][y].push(entity));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      } else if (entity.hitboxType === RECTANGLE) {
        _results1 = [];
        for (x = _j = _ref2 = Math.floor((entity.x - entity.halfWidth) / this.collisionCellSidelength), _ref3 = Math.floor((entity.x + entity.halfWidth) / this.collisionCellSidelength); _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
          _results1.push((function() {
            var _k, _ref4, _ref5, _results2;
            _results2 = [];
            for (y = _k = _ref4 = Math.floor((entity.y - entity.halfHeight) / this.collisionCellSidelength), _ref5 = Math.floor((entity.y + entity.halfHeight) / this.collisionCellSidelength); _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; y = _ref4 <= _ref5 ? ++_k : --_k) {
              if ((0 < x && x < this.collisionMapWidth) && (0 < y && y < this.collisionMapHeight)) {
                _results2.push(this.collisionMap[x][y].push(entity));
              } else {
                _results2.push(void 0);
              }
            }
            return _results2;
          }).call(this));
        }
        return _results1;
      }
    };

    Frame.prototype.doesCollide = function(entity) {
      var key, partner, potentialPartner, potentialPartners, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      potentialPartners = {};
      if (entity.hitboxType === CIRCLE) {
        for (x = _i = _ref = Math.floor((entity.x - entity.radius) / this.collisionCellSidelength), _ref1 = Math.floor((entity.x + entity.radius) / this.collisionCellSidelength); _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
          for (y = _j = _ref2 = Math.floor((entity.y - entity.radius) / this.collisionCellSidelength), _ref3 = Math.floor((entity.y + entity.radius) / this.collisionCellSidelength); _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
            if ((0 < x && x < this.collisionMapWidth) && (0 < y && y < this.collisionMapHeight)) {
              _ref4 = this.collisionMap[x][y];
              for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
                potentialPartner = _ref4[_k];
                potentialPartners[potentialPartner.id] = potentialPartner;
              }
            }
          }
        }
      }
      for (key in potentialPartners) {
        partner = potentialPartners[key];
        if (this.doesCollideWith(entity, partner)) {
          return partner;
        }
      }
      return false;
    };

    Frame.prototype.doesCollideWith = function(entity, partner) {
      var a, b, c, d, e, partnerPointInRect, r, sqRadius, squareDist;
      if (entity === partner || !partner.alive) {
        return false;
      }
      squareDist = function(x1, y1, x2, y2) {
        return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
      };
      if (partner.hitboxType === RECTANGLE) {
        partnerPointInRect = function(x, y) {
          return pointInRect(x, y, partner.x, partner.y, partner.halfWidth, partner.halfHeight);
        };
        a = partnerPointInRect(entity.x + entity.radius, entity.y);
        b = partnerPointInRect(entity.x - entity.radius, entity.y);
        c = partnerPointInRect(entity.x, entity.y + entity.radius);
        d = partnerPointInRect(entity.x, entity.y - entity.radius);
        sqRadius = Math.pow(entity.radius, 2);
        e = sqRadius > squareDist(entity.x, entity.y, partner.x + partner.halfWidth, partner.y - partner.halfHeight) || sqRadius > squareDist(entity.x, entity.y, partner.x - partner.halfWidth, partner.y - partner.halfHeight) || sqRadius > squareDist(entity.x, entity.y, partner.x + partner.halfWidth, partner.y + partner.halfHeight) || sqRadius > squareDist(entity.x, entity.y, partner.x - partner.halfWidth, partner.y + partner.halfHeight);
        return a || b || c || d || e;
      } else if (partner.hitboxType === CIRCLE) {
        d = squareDist(entity.x, entity.y, partner.x, partner.y);
        r = Math.pow(entity.radius + partner.radius, 2);
        return d < r;
      }
    };

    Frame.prototype.collide = function(partner1, partner2) {
      if (partner1.operatorLevel === 0 && partner2.operatorLevel === 0) {
        this.physicalCollide(partner1, partner2);
      } else if (partner1.operatorLevel > partner2.operatorLevel) {
        partner1.collide(partner2);
      } else if (partner2.operatorLevel > partner1.operatorLevel) {
        partner2.collide(partner1);
      }
      partner1.hasCollided(partner2);
      return partner2.hasCollided(partner1);
    };

    Frame.prototype.physicalCollide = function(partner1, partner2) {
      var circle, dog, newVelX1, newVelX2, newVelY1, newVelY2, printCoords, rect, xdist, ydist;
      if (partner1.hitboxType === NON_PHYSICAL || partner2.hitboxType === NON_PHYSICAL) {
        return dog = 1;
      } else if (partner1.hitboxType === RECTANGLE || partner2.hitboxType === RECTANGLE) {
        if (partner1.hitboxType === RECTANGLE) {
          rect = partner1;
          circle = partner2;
        } else {
          rect = partner2;
          circle = partner1;
        }
        xdist = Math.abs(circle.x - rect.x);
        ydist = Math.abs(circle.y - rect.y);
        if (circle.x > rect.x) {
          if (circle.y > rect.y) {
            if (xdist < ydist) {
              circle.yVelocity = -circle.yVelocity;
              return circle.y = rect.y + rect.halfHeight + circle.radius;
            } else {
              circle.xVelocity = -circle.xVelocity;
              return circle.x = rect.x + rect.halfWidth + circle.radius;
            }
          } else {
            if (xdist < ydist) {
              circle.yVelocity = -circle.yVelocity;
              return circle.y = rect.y - rect.halfHeight - circle.radius;
            } else {
              circle.xVelocity = -circle.xVelocity;
              return circle.x = rect.x + rect.halfWidth + circle.radius;
            }
          }
        } else {
          if (circle.y > rect.y) {
            if (xdist < ydist) {
              circle.yVelocity = -circle.yVelocity;
              return circle.y = rect.y + rect.halfHeight + circle.radius;
            } else {
              circle.xVelocity = -circle.xVelocity;
              return circle.x = rect.x - rect.halfWidth - circle.radius;
            }
          } else {
            if (xdist < ydist) {
              circle.yVelocity = -circle.yVelocity;
              return circle.y = rect.y - rect.halfHeight - circle.radius;
            } else {
              circle.xVelocity = -circle.xVelocity;
              return circle.x = rect.x - rect.halfWidth - circle.radius;
            }
          }
        }
      } else if (partner1.hitboxType === CIRCLE && partner2.hitboxType === CIRCLE) {
        console.log('circle on circle collision');
        '\
                        midpointx = (partner1.x + partner2.x)/2\
                        midpointy = (partner1.y + partner2.y)/2\
                        dist = Math.sqrt(Math.pow(partner1.x-partner2.x, 2) + Math.pow(partner1.y-partner2.y, 2))\
                        newx = midpointx + partner1.radius * (partner1.x - partner2.x)/dist\
                        newy = midpointy + partner1.radius * (partner1.y - partner2.y)/dist\
                        partner2.x = midpointx + partner2.radius * (partner2.x - partner1.x)/dist #Debug here and below as well, are the state changes intentional?\
                        partner2.y = midpointy + partner2.radius * (partner2.y - partner1.y)/dist\
                        partner1.x = newx\
                        partner1.y = newy\
                        ';

        '\
                        partner1.x -= partner1.xVelocity\
                        partner1.y -= partner1.yVelocity\
\
                        partner2.x -= partner2.xVelocity\
                        partner2.y -= partner2.yVelocity\
                        ';

        printCoords = function(entity) {
          return console.log(entity.id + ' :(' + entity.x + ', ' + entity.y + ')');
        };
        console.log(partner1.id + 'VEL-precollision: (' + partner1.xVelocity + ' ,' + partner1.yVelocity + ')');
        printCoords(partner1);
        console.log(partner2.id + 'VEL-precollision: (' + partner2.xVelocity + ' ,' + partner2.yVelocity + ')');
        printCoords(partner2);
        "                        console.log('************************************COLLISION--HAPPENS***********************************')                        d = partner1.radius + partner2.radius #THIS LINE IS POTENTIAL DEBUG POINT                        nx = (partner2.x - partner1.x)/d                        ny = (partner2.y - partner1.y)/d                        p = 2*(partner1.xVelocity*nx + partner1.yVelocity*ny - partner2.xVelocity*nx - partner2.yVelocity*ny)/(partner1.mass + partner2.mass)                        partner1.xVelocity = partner1.xVelocity - p*partner2.mass*nx                        partner1.yVelocity = partner1.yVelocity - p*partner2.mass*ny                        partner2.xVelocity = partner2.xVelocity + p*partner1.mass*nx                        partner2.yVelocity = partner2.yVelocity + p*partner1.mass*ny                        ";

        newVelX1 = (partner1.xVelocity * (partner1.mass - partner2.mass) + (2 * partner2.mass * partner2.xVelocity)) / (partner1.mass + partner2.mass);
        newVelY1 = (partner1.yVelocity * (partner1.mass - partner2.mass) + (2 * partner2.mass * partner2.yVelocity)) / (partner1.mass + partner2.mass);
        newVelX2 = (partner2.xVelocity * (partner2.mass - partner1.mass) + (2 * partner1.mass * partner1.xVelocity)) / (partner1.mass + partner2.mass);
        newVelY2 = (partner2.yVelocity * (partner2.mass - partner1.mass) + (2 * partner1.mass * partner1.yVelocity)) / (partner1.mass + partner2.mass);
        partner1.physics(-2);
        partner2.physics(-2);
        partner1.xVelocity = newVelX1;
        partner2.yVelocity = newVelY1;
        partner1.xVelocity = newVelX2;
        partner2.yVelocity = newVelY2;
        '\
                        partner1.x += partner1.xVelocity\
                        partner1.y += partner1.yVelocity\
                        partner2.x += partner2.xVelocity\
                        partner2.y += partner2.yVelocity\
                        ';

        console.log(partner1.id + 'VEL-postcollision: (' + partner1.xVelocity + ' ,' + partner1.yVelocity + ')');
        printCoords(partner1);
        console.log(partner2.id + 'VEL-postcollision: (' + partner2.xVelocity + ' ,' + partner2.yVelocity + ')');
        return printCoords(partner2);
      }
    };

    return Frame;

  })();

  BasicFrame = (function(_super) {

    __extends(BasicFrame, _super);

    function BasicFrame(_width, _height, _graphics) {
      var x, y, _i, _j;
      BasicFrame.__super__.constructor.call(this, _width, _height, _graphics);
      this.wallWidth = this.width / 40;
      this.wallHeight = this.wallWidth;
      for (x = _i = 0; _i < 40; x = ++_i) {
        this.map.push(new Wall(this.map, this.newId(), this.graphics, x * this.wallWidth + 0.5 * this.wallWidth, 0 + 0.5 * this.wallHeight, 0.5 * this.wallWidth, 0.5 * this.wallHeight));
        this.map.push(new Wall(this.map, this.newId(), this.graphics, x * this.wallWidth + 0.5 * this.wallWidth, this.height - 0.5 * this.wallHeight, 0.5 * this.wallWidth, 0.5 * this.wallHeight));
      }
      for (y = _j = 0; _j < 20; y = ++_j) {
        this.map.push(new Wall(this.map, this.newId(), this.graphics, 0 + 0.5 * this.wallWidth, y * this.wallHeight + 0.5 * this.wallHeight, 0.5 * this.wallWidth, 0.5 * this.wallHeight));
        this.map.push(new Wall(this.map, this.newId(), this.graphics, this.width - 0.5 * this.wallWidth, y * this.wallHeight + 0.5 * this.wallHeight, 0.5 * this.wallWidth, 0.5 * this.wallHeight));
      }
    }

    return BasicFrame;

  })(Frame);

  Entity = (function() {

    function Entity(map, id, graphics, x, y) {
      this.map = map;
      this.id = id;
      this.graphics = graphics;
      this.x = x;
      this.y = y;
      this.hitboxType = NON_PHYSICAL;
      this.collisionType = STATIC;
      this.operatorLevel = NON_OPERATOR;
      this.alive = true;
      this.idCount = 0;
      this.health = 1;
      this.imageCentreX = 0;
      this.imageCentreY = 0;
    }

    Entity.prototype.draw = function(context) {};

    Entity.prototype.collide = function(partner) {};

    Entity.prototype.hasCollided = function(partner) {};

    Entity.prototype.damage = function() {};

    Entity.prototype.updateInput = function(events, mousex, mousey) {};

    Entity.prototype.newId = function() {
      this.idCount++;
      return this.id + ":" + String(this.idCount);
    };

    Entity.prototype.run = function() {};

    return Entity;

  })();

  Wall = (function(_super) {

    __extends(Wall, _super);

    function Wall(_map, _id, _graphics, _x, _y, halfWidth, halfHeight) {
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
      Wall.__super__.constructor.call(this, _map, _id, _graphics, _x, _y);
      this.hitboxType = RECTANGLE;
      this.operatorLevel = NON_OPERATOR;
      this.image = this.graphics['resources/gems2-15.png'];
    }

    Wall.prototype.draw = function(context) {
      return context.drawImage(this.image, this.x - this.halfWidth, this.y - this.halfHeight, 2 * this.halfWidth, 2 * this.halfHeight);
    };

    Wall.prototype.run = function(elapsedTime) {};

    return Wall;

  })(Entity);

  Portal = (function(_super) {

    __extends(Portal, _super);

    function Portal(_map, _id, _graphics, _x, _y, exit, frame, halfWidth, halfHeight) {
      this.exit = exit;
      this.frame = frame;
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
      Portal.__super__.constructor.call(this, _map, _id, _graphics, _x, _y);
      this.hitboxType = RECTANGLE;
      this.operatorLevel = OPERATOR;
      this.spawnx = 0;
      this.spawny = 0;
    }

    Portal.prototype.collide = function(partner) {
      console.log('portal collide!');
      if (partner.id === 'player') {
        this.exit.receivePlayer(partner);
        return this.frame.active = false;
      }
    };

    Portal.prototype.receivePlayer = function(player) {
      player.x = this.spawnx;
      player.y = this.spawny;
      this.frame.player = player;
      this.frame.map.push(player);
      return this.frame.active = true;
    };

    Portal.prototype.draw = function(context) {
      return context.fillRect(this.x - this.halfWidth, this.y - this.halfHeight, 2 * this.halfWidth, 2 * this.halfHeight);
    };

    return Portal;

  })(Entity);

  Mobile = (function(_super) {

    __extends(Mobile, _super);

    function Mobile(_map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity) {
      Mobile.__super__.constructor.call(this, _map, _id, _graphics, _x, _y);
      this.hitboxType = CIRCLE;
      this.collisionType = DYNAMIC;
      this.radius = _radius;
      this.mass = _mass;
      this.xVelocity = _xVelocity;
      this.yVelocity = _yVelocity;
      this.xForce = 0;
      this.yForce = 0;
      this.xAcceleration = 0;
      this.yAcceleration = 0;
      this.name = "Nil";
      this.lastTime = 0;
    }

    Mobile.prototype.physics = function(elapsedTime) {
      this.xAcceleration = this.xForce / this.mass;
      this.yAcceleration = this.yForce / this.mass;
      this.x += (1 / 2) * this.xAcceleration * elapsedTime * elapsedTime + this.xVelocity * elapsedTime;
      this.y += (1 / 2) * this.yAcceleration * elapsedTime * elapsedTime + this.yVelocity * elapsedTime;
      this.xVelocity = this.xAcceleration * elapsedTime + this.xVelocity;
      return this.yVelocity = this.yAcceleration * elapsedTime + this.yVelocity;
    };

    Mobile.prototype.collide = function(partner) {
      return console.log('handling collide when i shouldnt be');
    };

    Mobile.prototype.run = function(elapsedTime) {
      return this.physics(elapsedTime);
    };

    return Mobile;

  })(Entity);

  Player = (function(_super) {

    __extends(Player, _super);

    function Player(_map, _id, _graphics, _x, _y, _radius) {
      var _mass, _xVelocity, _yVelocity;
      Player.__super__.constructor.call(this, _map, _id, _graphics, _x, _y, _radius, _mass = 1, _xVelocity = 0, _yVelocity = 0);
      this.mousex = 0;
      this.mousey = 0;
      this.thrustForward = false;
      this.thrustBackward = false;
      this.fire = false;
      this.animation = new PlayerAnimation(this, this.graphics, this.x, this.y);
      this.imageCentreX = 27;
      this.imageCentreY = 30;
      this.image = this.graphics['resources/warrior1_0-test-01.png'];
    }

    Player.prototype.updateInput = function(events, _mousex, _mousey) {
      var event, _i, _len, _results;
      this.mousex = _mousex;
      this.mousey = _mousey;
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        event = events[_i];
        _results.push(this.processEvent(event));
      }
      return _results;
    };

    Player.prototype.fireBullet = function(fireDirectionX, fireDirectionY) {
      var bulletradius, bulletspeed, _graphics, _id, _map, _mass, _radius, _x, _xVelocity, _y, _yVelocity;
      bulletspeed = 10;
      bulletradius = 5;
      return this.map.push(new Bullet(_map = this.map, _id = this.newId(), _graphics = this.graphics, _x = this.x + fireDirectionX * (this.radius + bulletradius + Math.abs(this.xVelocity)), _y = this.y + fireDirectionY * (this.radius + bulletradius + Math.abs(this.yVelocity)), _radius = bulletradius, _mass = 1, _xVelocity = this.xVelocity + fireDirectionX * bulletspeed, _yVelocity = this.yVelocity + fireDirectionY * bulletspeed));
    };

    Player.prototype.fireMissiles = function(destinationX, destinationY) {
      var initialThrust, missile1, missile1DirectionX, missile1DirectionY, missile1radius, missile2, missile2DirectionX, missile2DirectionY, missile2radius, _destinationX, _destinationY, _mass, _radius, _x, _xVelocity, _y, _yVelocity;
      initialThrust = 2;
      missile1radius = 5;
      missile2radius = 5;
      missile1DirectionX = -this.directionY;
      missile1DirectionY = this.directionX;
      missile2DirectionX = this.directionY;
      missile2DirectionY = -this.directionX;
      missile1 = new Missile(this.map, this.newId(), this.graphics, _x = this.x + missile1DirectionX * (this.radius + missile1radius), _y = this.y + missile1DirectionY * (this.radius + missile1radius), _radius = missile1radius, _mass = 1, _xVelocity = this.xVelocity + missile1DirectionX * initialThrust, _yVelocity = this.yVelocity + missile1DirectionY * initialThrust, _destinationX = destinationX, _destinationY = destinationY);
      missile2 = new Missile(this.map, this.newId(), this.graphics, _x = this.x + missile2DirectionX * (this.radius + missile2radius), _y = this.y + missile2DirectionY * (this.radius + missile2radius), _radius = missile2radius, _mass = 1, _xVelocity = this.xVelocity + missile2DirectionX * initialThrust, _yVelocity = this.yVelocity + missile2DirectionY * initialThrust, _destinationX = destinationX, _destinationY = destinationY);
      return this.map.push(missile1, missile2);
    };

    Player.prototype.processEvent = function(event) {
      if (event.type === 'keydown') {
        switch (event.keyCode) {
          case KEY_SPACE:
            return this.fire = true;
          case KEY_UP_ARROW:
            return this.thrustForward = true;
          case KEY_DOWN_ARROW:
            return this.thrustBackward = true;
          case KEY_LEFT_SHIFT:
            return this.doFireMissiles = true;
          default:
            return console.log("Unexpected keycode: " + event.keyCode);
        }
      } else if (event.type === 'keyup') {
        switch (event.keyCode) {
          case KEY_UP_ARROW:
            return this.thrustForward = false;
          case KEY_DOWN_ARROW:
            return this.thrustBackward = false;
          default:
            return console.log("Unexpected keycode");
        }
      }
    };

    Player.prototype.damage = function(damageTaken) {
      return this.animation.animateShield = true;
    };

    Player.prototype.run = function(elapsedTime) {
      var dist;
      dist = Math.sqrt(Math.pow(this.x - this.mousex, 2) + Math.pow(this.y - this.mousey, 2));
      this.directionX = (this.mousex - this.x) / dist;
      this.directionY = (this.mousey - this.y) / dist;
      if (this.thrustForward) {
        this.xForce += this.directionX * 0.1;
        this.yForce += this.directionY * 0.1;
      } else if (this.thrustBackward) {
        this.xForce -= this.directionX * 0.1;
        this.yForce -= this.directionY * 0.1;
      }
      if (this.fire) {
        this.fireBullet(this.directionX, this.directionY);
        this.fire = false;
      }
      if (this.doFireMissiles) {
        this.fireMissiles(this.mousex, this.mousey);
        this.doFireMissiles = false;
      }
      this.physics(elapsedTime);
      this.xForce = 0;
      return this.yForce = 0;
    };

    Player.prototype.draw = function(context) {
      var dotProd, vectorToRadians;
      dotProd = function(x1, y1, x2, y2) {
        return x1 * x2 + y1 * y2;
      };
      vectorToRadians = function(x, y) {
        var theta;
        theta = Math.acos(dotProd(x, y, 1, 0));
        if (y < 0) {
          return 2 * 3.14 - theta;
        } else {
          return theta;
        }
      };
      context.save();
      context.translate(this.x, this.y);
      context.rotate(vectorToRadians(this.directionX, this.directionY));
      context.drawImage(this.image, -this.imageCentreX, -this.imageCentreY);
      context.translate(this.x, this.y);
      context.restore();
      return this.animation.draw(context);
    };

    Player.prototype.hasCollided = function(partner) {
      console.log(partner.id);
      if (partner.id === 'asteroid') {
        return this.damage(0.5);
      }
    };

    return Player;

  })(Mobile);

  Bullet = (function(_super) {

    __extends(Bullet, _super);

    function Bullet(_map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity) {
      Bullet.__super__.constructor.call(this, _map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity);
      this.xVelocity = _xVelocity;
      this.yVelocity = _yVelocity;
      this.operatorLevel = OPERATOR;
      this.hitboxType = CIRCLE;
      this.collisionType = DYNAMIC;
      this.damage = 5;
    }

    Bullet.prototype.collide = function(partner) {
      if (partner.id !== 'player') {
        partner.damage(this.damage);
        return this.alive = false;
      }
    };

    Bullet.prototype.draw = function(context) {
      context.beginPath();
      context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, true);
      return context.fill();
    };

    Bullet.prototype.run = function(elapsedTime) {
      return this.physics(elapsedTime);
    };

    return Bullet;

  })(Mobile);

  Asteroid = (function(_super) {

    __extends(Asteroid, _super);

    function Asteroid(_map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity) {
      Asteroid.__super__.constructor.call(this, _map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity);
      this.operatorLevel = NON_OPERATOR;
      this.hitboxType = CIRCLE;
      this.collisionType = DYNAMIC;
      this.image = this.graphics['resources/jswars_gfx/asteroid.png'];
      this.imageCentreX = 1.5 * this.radius;
      this.imageCentreY = 1.5 * this.radius;
      this.health = 15;
    }

    Asteroid.prototype.draw = function(context) {
      return context.drawImage(this.image, this.x - this.imageCentreX, this.y - this.imageCentreY, 2 * this.imageCentreX, 2 * this.imageCentreY);
    };

    Asteroid.prototype.run = function(elapsedTime) {
      var child1, child2, child3, child4;
      if (this.health < 1) {
        this.alive = false;
        child1 = new Asteroid(this.map, this.newId(), this.graphics, this.x + this.radius / 2, this.y + this.radius / 2, this.radius / 2, this.mass / 4, this.xVelocity / 4 + 1, this.yVelocity / 4 + 1);
        child2 = new Asteroid(this.map, this.newId(), this.graphics, this.x + this.radius / 2, this.y - this.radius / 2, this.radius / 2, this.mass / 4, this.xVelocity / 4 + 1, this.yVelocity / 4 - 1);
        child3 = new Asteroid(this.map, this.newId(), this.graphics, this.x - this.radius / 2, this.y + this.radius / 2, this.radius / 2, this.mass / 4, this.xVelocity / 4 - 1, this.yVelocity / 4 + 1);
        child4 = new Asteroid(this.map, this.newId(), this.graphics, this.x - this.radius / 2, this.y - this.radius / 2, this.radius / 2, this.mass / 4, this.xVelocity / 4 - 1, this.yVelocity / 4 - 1);
        return this.map.push(child1, child2, child3, child4);
      } else {
        return this.physics(elapsedTime);
      }
    };

    Asteroid.prototype.damage = function(damageTaken) {
      return this.health -= damageTaken;
    };

    return Asteroid;

  })(Mobile);

  PlayerAnimation = (function() {

    function PlayerAnimation(player, graphics, x, y) {
      this.player = player;
      this.graphics = graphics;
      this.x = x;
      this.y = y;
      this.animateShield = true;
      this.shieldImageIterator = 0;
      this.shieldImageIndex = 0;
      this.shieldImageIndexMax = 7;
      this.rotation = 0;
      this.active = true;
    }

    PlayerAnimation.prototype.draw = function(context) {
      var imgHeight, imgWidth;
      if (this.animateShield) {
        console.log('Sheild is animated!');
        context.globalAlpha = 0.5;
        context.drawImage(this.graphics['resources/shieldAnimation/pwr02test2-' + this.shieldImageIndex + '.png'], this.player.x - this.player.radius * 1.26, this.player.y - this.player.radius * 1.26, imgWidth = 1.26 * this.player.radius * 2, imgHeight = 1.26 * this.player.radius * 2);
        context.globalAlpha = 1;
        if (this.shieldImageIndexMax === this.shieldImageIndex) {
          this.shieldImageIndex = 0;
          return this.animateShield = false;
        } else if (this.shieldImageIterator === 2) {
          this.shieldImageIndex++;
          return this.shieldImageIterator = 0;
        } else {
          return this.shieldImageIterator++;
        }
      }
    };

    return PlayerAnimation;

  })();

  Missile = (function(_super) {

    __extends(Missile, _super);

    function Missile(_map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity, _destinationX, _destinationY) {
      Missile.__super__.constructor.call(this, _map, _id, _graphics, _x, _y, _radius, _mass, _xVelocity, _yVelocity);
      this.xVelocity = _xVelocity;
      this.yVelocity = _yVelocity;
      this.operatorLevel = OPERATOR;
      this.hitboxType = CIRCLE;
      this.collisionType = DYNAMIC;
      this.damage = 5;
      this.destinationX = _destinationX;
      this.destinationY = _destinationY;
      this.thrust = 200;
    }

    Missile.prototype.collide = function(partner) {
      if (partner.id !== 'player') {
        partner.damage(this.damage);
        return this.alive = false;
      }
    };

    Missile.prototype.draw = function(context) {
      context.beginPath();
      context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, true);
      return context.fill();
    };

    Missile.prototype.run = function(elapsedTime) {
      var dist;
      dist = Math.sqrt(Math.pow(this.destinationX - this.x, 2) + Math.pow(this.destinationY - this.y, 2));
      if (dist < 20) {
        this.alive = false;
      }
      this.directionX = (this.destinationX - this.x) / dist;
      this.directionY = (this.destinationY - this.y) / dist;
      this.xForce = this.directionX * Math.max(this.thrust * (1 / (dist * 10)), 2);
      this.yForce = this.directionY * Math.max(this.thrust * (1 / (dist * 10)), 2);
      return this.physics(elapsedTime);
    };

    return Missile;

  })(Mobile);

  testWall = (function(_super) {

    __extends(testWall, _super);

    function testWall(_map, _id, _graphics, _x, _y, halfWidth, halfHeight) {
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
      testWall.__super__.constructor.call(this, _map, _id, _graphics, _x, _y);
      this.hitboxType = RECTANGLE;
    }

    testWall.prototype.draw = function(context) {
      return context.fillRect(this.x - this.halfWidth, this.y - this.halfHeight, 2 * this.halfWidth, 2 * this.halfHeight);
    };

    testWall.prototype.run = function(elapsedTime) {};

    return testWall;

  })(Entity);

  start = function(canvas) {
    window.game = new Game(canvas);
    window.game.frames.push(new BasicFrame(1000, 500, window.game.graphics));
    window.game.frames[0].active = true;
    window.game.frames[0].map.push(new Asteroid(window.game.frames[0].map, 'asteroid', window.game.graphics, 300, 300, 30, 1, 0, 0));
    window.game.frames[0].map.push(new Player(window.game.frames[0].map, 'player', window.game.graphics, 200, 200, 40));
    return setInterval("window.game.run()", 20);
  };

  window.startGame = function(canvas) {
    return start(canvas);
  };

}).call(this);
